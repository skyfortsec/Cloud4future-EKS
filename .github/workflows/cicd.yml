name: full-cicd-infra-and-app

on:
  push:
    branches: ["main"]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-2
  TF_DIR: infra/platform
  K8S_NAMESPACE: staging

jobs:
  infra:
    runs-on: ubuntu-latest
    outputs:
      cluster_name: ${{ steps.tf_outputs.outputs.cluster_name }}
      ecr_repo_url: ${{ steps.tf_outputs.outputs.ecr_repo_url }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=platform/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Validate
        working-directory: ${{ env.TF_DIR }}
        run: terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_DIR }}
        run: |
          terraform plan \
            -var="my_public_ip_cidr=${{ secrets.MY_PUBLIC_IP_CIDR }}" \
            -var="github_actions_role_arn=${{ secrets.AWS_ROLE_TO_ASSUME }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ${{ env.TF_DIR }}
        run: terraform apply -auto-approve tfplan

      - name: Export Terraform Outputs
        id: tf_outputs
        working-directory: ${{ env.TF_DIR }}
        run: |
          echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "ecr_repo_url=$(terraform output -raw ecr_repo_url)" >> $GITHUB_OUTPUT

  app:
    runs-on: ubuntu-latest
    needs: infra
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build Docker image
        run: docker build -t app:${{ github.sha }} ./app

      - name: Tag image for ECR
        run: |
          IMAGE_URI="${{ needs.infra.outputs.ecr_repo_url }}:${{ github.sha }}"
          docker tag app:${{ github.sha }} "$IMAGE_URI"
          echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV

      # âœ… Updated: Trivy will NOT block deployment anymore
      - name: Trivy scan (log HIGH/CRITICAL but do not fail)
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: "${{ env.IMAGE_URI }}"
          format: "table"
          severity: "HIGH,CRITICAL"
          ignore-unfixed: true
          vuln-type: "os,library"
          exit-code: "0"

      - name: Push image to ECR
        run: |
          docker push "${{ env.IMAGE_URI }}"

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: "v1.29.0"

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --name "${{ needs.infra.outputs.cluster_name }}" \
            --region "${{ env.AWS_REGION }}"

      - name: Deploy to EKS
        run: |
          kubectl apply -f k8s/namespace.yaml
          sed -i "s|__IMAGE_URI__|${{ env.IMAGE_URI }}|g" k8s/deployment.yaml
          kubectl apply -f k8s/
          kubectl rollout status deploy/my-node-app -n ${{ env.K8S_NAMESPACE }} --timeout=300s

      - name: Show Ingress (ALB address)
        run: kubectl get ingress -n ${{ env.K8S_NAMESPACE }} -o wide
